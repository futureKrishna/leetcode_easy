tThe logic of kadane's algorithm is that, whenever the currentSum becomes less than 0, the next element will not combine it with itself, the new element will start fresh.
and if the currectSum remains 0 or greater than 0,the new element will combine itself with the previous elements to become a bigger number.

Here,we created a bestSum and a currentSum variables, initialized them to the start element , tracersed over the loop and if the currentSum is greater than 0 ,
we are adding the new element to it and if the currentSum is less than 0 , then we are taking ith element in the currentSum.
and if at any point if the value of currectSum is greater than bestSum, we are updating the best sum and returning it.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int csum=nums[0];
        int bsum=nums[0];
        for(int i=1;i<nums.size();i++){
            if(csum>0){
                csum+=nums[i];
            }
            else{
                csum=nums[i];
            }
            if(csum>bsum){
                bsum=csum;
            }
        }
        return bsum;
    }
};
